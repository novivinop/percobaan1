{"ast":null,"code":"export default class PureCounter {\n  constructor(options) {\n    this.defaults = {\n      start: 0,\n      end: 100,\n      duration: 2000,\n      delay: 10,\n      once: true,\n      decimals: 0,\n      legacy: true,\n      currency: false,\n      currencysymbol: false,\n      separator: false,\n      separatorsymbol: ',',\n      selector: '.purecounter'\n    };\n    this.configOptions = Object.assign({}, this.defaults, options || {});\n    this.registerEventListeners();\n  }\n  /** Initial function */\n\n  registerEventListeners() {\n    /** Get all elements with class 'purecounter' */\n    var elements = document.querySelectorAll(this.configOptions.selector);\n    /** Get browser Intersection Listener Support */\n\n    var intersectionSupported = this.intersectionListenerSupported();\n    /** Run animateElements base on Intersection Support */\n\n    if (intersectionSupported) {\n      var intersectObserver = new IntersectionObserver(this.animateElements.bind(this), {\n        \"root\": null,\n        \"rootMargin\": '20px',\n        \"threshold\": 0.5\n      });\n      elements.forEach(element => {\n        intersectObserver.observe(element);\n      });\n    } else {\n      if (window.addEventListener) {\n        this.animateLegacy(elements);\n        window.addEventListener('scroll', function (e) {\n          this.animateLegacy(elements);\n        }, {\n          \"passive\": true\n        });\n      }\n    }\n  }\n  /** This legacy to make Purecounter use very lightweight & fast */\n\n  animateLegacy(elements) {\n    elements.forEach(element => {\n      var config = this.parseConfig(element);\n      if (config.legacy === true && this.elementIsInView(element)) {\n        this.animateElements([element]);\n      }\n    });\n  }\n  /** Main Element Count Animation */\n\n  animateElements(elements, observer) {\n    elements.forEach(element => {\n      var elm = element.target || element; // Just make sure which element will be used\n\n      var elementConfig = this.parseConfig(elm); // Get config value on that element\n      // If duration is less than or equal zero, just format the 'end' value\n\n      if (elementConfig.duration <= 0) {\n        return elm.innerHTML = this.formatNumber(elementConfig.end, elementConfig);\n      }\n      if (!observer && !this.elementIsInView(element) || observer && element.intersectionRatio < 0.5) {\n        var value = elementConfig.start > elementConfig.end ? elementConfig.end : elementConfig.start;\n        return elm.innerHTML = this.formatNumber(value, elementConfig);\n      } // If duration is more than 0, then start the counter\n\n      setTimeout(() => {\n        return this.startCounter(elm, elementConfig);\n      }, elementConfig.delay);\n    });\n  }\n  /** This is the the counter method */\n\n  startCounter(element, config) {\n    // First, get the increments step\n    var incrementsPerStep = (config.end - config.start) / (config.duration / config.delay); // Next, set the counter mode (Increment or Decrement)\n\n    var countMode = 'inc'; // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\n\n    if (config.start > config.end) {\n      countMode = 'dec';\n      incrementsPerStep *= -1;\n    } // Next, determine the starting value\n\n    var currentCount = this.parseValue(config.start); // And then print it's value to the page\n\n    element.innerHTML = this.formatNumber(currentCount, config); // If the config 'once' is true, then set the 'duration' to 0\n\n    if (config.once === true) {\n      element.setAttribute('data-purecounter-duration', 0);\n    } // Now, start counting with counterWorker using Interval method based on delay\n\n    var counterWorker = setInterval(() => {\n      // First, determine the next value base on current value, increment value, and count mode\n      var nextNum = this.nextNumber(currentCount, incrementsPerStep, countMode); // Next, print that value to the page\n\n      element.innerHTML = this.formatNumber(nextNum, config); // Now set that value to the current value, because it's already printed\n\n      currentCount = nextNum; // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\n\n      if (currentCount >= config.end && countMode === 'inc' || currentCount <= config.end && countMode === 'dec') {\n        element.innerHTML = this.formatNumber(config.end, config);\n        clearInterval(counterWorker);\n      }\n    }, config.delay);\n  }\n  /** This function is to generate the element Config */\n\n  parseConfig(element) {\n    // First, we need to declare the base Config\n    // This config will be used if the element doesn't have config\n    var baseConfig = {\n      ...this.configOptions\n    }; // Next, get all 'data-precounter' attributes value. Store to array\n\n    var configValues = [].filter.call(element.attributes, function (attr) {\n      return /^data-purecounter-/.test(attr.name);\n    }); // Now, we create element config as an empty object\n\n    var elementConfig = {}; // And then, fill the element config based on config values\n\n    configValues.forEach(e => {\n      var name = e.name.replace('data-purecounter-', '').toLowerCase();\n      var value = name === 'duration' ? parseInt(this.parseValue(e.value) * 1000) : this.parseValue(e.value);\n      elementConfig[name] = value; // We will get an object\n    }); // Last marge base config with element config and return it as an object\n\n    return Object.assign(baseConfig, elementConfig);\n  }\n  /** This function is to get the next number */\n\n  nextNumber(number, steps) {\n    let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'inc';\n    // First, get the exact value from the number and step (int or float)\n    number = this.parseValue(number);\n    steps = this.parseValue(steps); // Last, get the next number based on current number, increment step, and count mode\n    // Always return it as float\n\n    return parseFloat(mode === 'inc' ? number + steps : number - steps);\n  }\n  /** This function is to convert number into currency format */\n\n  convertToCurrencySystem(num, config) {\n    var symbol = config.currencysymbol || \"\",\n      // Set the Currency Symbol (if any)\n      limit = config.decimals || 1,\n      // Set the decimal limit (default is 1)\n      number = Math.abs(Number(num)); // Get the absolute value of number\n    // Set the value\n\n    var value = number >= 1.0e+12 ? `${(number / 1.0e+12).toFixed(limit)} T` // Twelve zeros for Trillions\n    : number >= 1.0e+9 ? `${(number / 1.0e+9).toFixed(limit)} B` // Nine zeros for Billions\n    : number >= 1.0e+6 ? `${(number / 1.0e+6).toFixed(limit)} M` // Six zeros for Millions\n    : number >= 1.0e+3 ? `${(number / 1.0e+12).toFixed(limit)} K` // Three zeros for Thousands\n    : number.toFixed(limit); // If less than 1000, print it's value\n    // Apply symbol before the value and return it as string\n\n    return symbol + value;\n  }\n  /** This function is to get the last formated number */\n\n  applySeparator(value, config) {\n    // If config separator is false, delete all separator\n    if (!config.separator) {\n      return value.replace(new RegExp(/,/gi, 'gi'), '');\n    } // If config separator is true, then create separator\n\n    return value.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\").replace(new RegExp(/,/gi, 'gi'), config.separatorsymbol);\n  }\n  /** This function is to get formated number to be printed in the page */\n\n  formatNumber(number, config) {\n    // This is the configuration for 'toLocaleString' method\n    var strConfig = {\n      minimumFractionDigits: config.decimals,\n      maximumFractionDigits: config.decimals\n    }; // Set the number if it using currency, then convert. If doesn't, just parse it as float\n\n    number = config.currency ? this.convertToCurrencySystem(number, config) : parseFloat(number); // Last, apply the number separator using number as string\n\n    return this.applySeparator(number.toLocaleString(undefined, strConfig), config);\n  }\n  /** This function is to get the parsed value */\n\n  parseValue(data) {\n    // If number with dot (.), will be parsed as float\n    if (/^[0-9]+\\.[0-9]+$/.test(data)) {\n      return parseFloat(data);\n    } // If just number, will be parsed as integer\n\n    if (/^[0-9]+$/.test(data)) {\n      return parseInt(data);\n    } // If it's boolean string, will be parsed as boolean\n\n    if (/^true|false/i.test(data)) {\n      return /^true/i.test(data);\n    } // Return it's value as default\n\n    return data;\n  }\n  /** This function is to detect the element is in view or not. */\n\n  elementIsInView(element) {\n    var top = element.offsetTop;\n    var left = element.offsetLeft;\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    while (element.offsetParent) {\n      element = element.offsetParent;\n      top += element.offsetTop;\n      left += element.offsetLeft;\n    }\n    return top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;\n  }\n  /** Just some condition to check browser Intersection Support */\n\n  intersectionListenerSupported() {\n    return 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype;\n  }\n}","map":{"version":3,"names":["PureCounter","constructor","options","defaults","start","end","duration","delay","once","decimals","legacy","currency","currencysymbol","separator","separatorsymbol","selector","configOptions","Object","assign","registerEventListeners","elements","document","querySelectorAll","intersectionSupported","intersectionListenerSupported","intersectObserver","IntersectionObserver","animateElements","bind","forEach","element","observe","window","addEventListener","animateLegacy","e","config","parseConfig","elementIsInView","observer","elm","target","elementConfig","innerHTML","formatNumber","intersectionRatio","value","setTimeout","startCounter","incrementsPerStep","countMode","currentCount","parseValue","setAttribute","counterWorker","setInterval","nextNum","nextNumber","clearInterval","baseConfig","configValues","filter","call","attributes","attr","test","name","replace","toLowerCase","parseInt","number","steps","mode","arguments","length","undefined","parseFloat","convertToCurrencySystem","num","symbol","limit","Math","abs","Number","toFixed","applySeparator","RegExp","strConfig","minimumFractionDigits","maximumFractionDigits","toLocaleString","data","top","offsetTop","left","offsetLeft","width","offsetWidth","height","offsetHeight","offsetParent","pageYOffset","pageXOffset","innerHeight","innerWidth","IntersectionObserverEntry","prototype"],"sources":["C:/Users/Asus/Documents/frontend TA/percobaan1/node_modules/react-statscounter/lib/PureCounter.js"],"sourcesContent":["export default class PureCounter {\n  constructor(options) {\n    this.defaults = {\n      start: 0,\n      end: 100,\n      duration: 2000,\n      delay: 10,\n      once: true,\n      decimals: 0,\n      legacy: true,\n      currency: false,\n      currencysymbol: false,\n      separator: false,\n      separatorsymbol: ',',\n      selector: '.purecounter'\n    };\n    this.configOptions = Object.assign({}, this.defaults, options || {});\n    this.registerEventListeners();\n  }\n  /** Initial function */\n\n\n  registerEventListeners() {\n    /** Get all elements with class 'purecounter' */\n    var elements = document.querySelectorAll(this.configOptions.selector);\n    /** Get browser Intersection Listener Support */\n\n    var intersectionSupported = this.intersectionListenerSupported();\n    /** Run animateElements base on Intersection Support */\n\n    if (intersectionSupported) {\n      var intersectObserver = new IntersectionObserver(this.animateElements.bind(this), {\n        \"root\": null,\n        \"rootMargin\": '20px',\n        \"threshold\": 0.5\n      });\n      elements.forEach(element => {\n        intersectObserver.observe(element);\n      });\n    } else {\n      if (window.addEventListener) {\n        this.animateLegacy(elements);\n        window.addEventListener('scroll', function (e) {\n          this.animateLegacy(elements);\n        }, {\n          \"passive\": true\n        });\n      }\n    }\n  }\n  /** This legacy to make Purecounter use very lightweight & fast */\n\n\n  animateLegacy(elements) {\n    elements.forEach(element => {\n      var config = this.parseConfig(element);\n\n      if (config.legacy === true && this.elementIsInView(element)) {\n        this.animateElements([element]);\n      }\n    });\n  }\n  /** Main Element Count Animation */\n\n\n  animateElements(elements, observer) {\n    elements.forEach(element => {\n      var elm = element.target || element; // Just make sure which element will be used\n\n      var elementConfig = this.parseConfig(elm); // Get config value on that element\n      // If duration is less than or equal zero, just format the 'end' value\n\n      if (elementConfig.duration <= 0) {\n        return elm.innerHTML = this.formatNumber(elementConfig.end, elementConfig);\n      }\n\n      if (!observer && !this.elementIsInView(element) || observer && element.intersectionRatio < 0.5) {\n        var value = elementConfig.start > elementConfig.end ? elementConfig.end : elementConfig.start;\n        return elm.innerHTML = this.formatNumber(value, elementConfig);\n      } // If duration is more than 0, then start the counter\n\n\n      setTimeout(() => {\n        return this.startCounter(elm, elementConfig);\n      }, elementConfig.delay);\n    });\n  }\n  /** This is the the counter method */\n\n\n  startCounter(element, config) {\n    // First, get the increments step\n    var incrementsPerStep = (config.end - config.start) / (config.duration / config.delay); // Next, set the counter mode (Increment or Decrement)\n\n    var countMode = 'inc'; // Set mode to 'decrement' and 'increment step' to minus if start is larger than end\n\n    if (config.start > config.end) {\n      countMode = 'dec';\n      incrementsPerStep *= -1;\n    } // Next, determine the starting value\n\n\n    var currentCount = this.parseValue(config.start); // And then print it's value to the page\n\n    element.innerHTML = this.formatNumber(currentCount, config); // If the config 'once' is true, then set the 'duration' to 0\n\n    if (config.once === true) {\n      element.setAttribute('data-purecounter-duration', 0);\n    } // Now, start counting with counterWorker using Interval method based on delay\n\n\n    var counterWorker = setInterval(() => {\n      // First, determine the next value base on current value, increment value, and count mode\n      var nextNum = this.nextNumber(currentCount, incrementsPerStep, countMode); // Next, print that value to the page\n\n      element.innerHTML = this.formatNumber(nextNum, config); // Now set that value to the current value, because it's already printed\n\n      currentCount = nextNum; // If the value is larger or less than the 'end' (base on mode), then  print the end value and stop the Interval\n\n      if (currentCount >= config.end && countMode === 'inc' || currentCount <= config.end && countMode === 'dec') {\n        element.innerHTML = this.formatNumber(config.end, config);\n        clearInterval(counterWorker);\n      }\n    }, config.delay);\n  }\n  /** This function is to generate the element Config */\n\n\n  parseConfig(element) {\n    // First, we need to declare the base Config\n    // This config will be used if the element doesn't have config\n    var baseConfig = { ...this.configOptions\n    }; // Next, get all 'data-precounter' attributes value. Store to array\n\n    var configValues = [].filter.call(element.attributes, function (attr) {\n      return /^data-purecounter-/.test(attr.name);\n    }); // Now, we create element config as an empty object\n\n    var elementConfig = {}; // And then, fill the element config based on config values\n\n    configValues.forEach(e => {\n      var name = e.name.replace('data-purecounter-', '').toLowerCase();\n      var value = name === 'duration' ? parseInt(this.parseValue(e.value) * 1000) : this.parseValue(e.value);\n      elementConfig[name] = value; // We will get an object\n    }); // Last marge base config with element config and return it as an object\n\n    return Object.assign(baseConfig, elementConfig);\n  }\n  /** This function is to get the next number */\n\n\n  nextNumber(number, steps, mode = 'inc') {\n    // First, get the exact value from the number and step (int or float)\n    number = this.parseValue(number);\n    steps = this.parseValue(steps); // Last, get the next number based on current number, increment step, and count mode\n    // Always return it as float\n\n    return parseFloat(mode === 'inc' ? number + steps : number - steps);\n  }\n  /** This function is to convert number into currency format */\n\n\n  convertToCurrencySystem(num, config) {\n    var symbol = config.currencysymbol || \"\",\n        // Set the Currency Symbol (if any)\n    limit = config.decimals || 1,\n        // Set the decimal limit (default is 1)\n    number = Math.abs(Number(num)); // Get the absolute value of number\n    // Set the value\n\n    var value = number >= 1.0e+12 ? `${(number / 1.0e+12).toFixed(limit)} T` // Twelve zeros for Trillions\n    : number >= 1.0e+9 ? `${(number / 1.0e+9).toFixed(limit)} B` // Nine zeros for Billions\n    : number >= 1.0e+6 ? `${(number / 1.0e+6).toFixed(limit)} M` // Six zeros for Millions\n    : number >= 1.0e+3 ? `${(number / 1.0e+12).toFixed(limit)} K` // Three zeros for Thousands\n    : number.toFixed(limit); // If less than 1000, print it's value\n    // Apply symbol before the value and return it as string\n\n    return symbol + value;\n  }\n  /** This function is to get the last formated number */\n\n\n  applySeparator(value, config) {\n    // If config separator is false, delete all separator\n    if (!config.separator) {\n      return value.replace(new RegExp(/,/gi, 'gi'), '');\n    } // If config separator is true, then create separator\n\n\n    return value.replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\").replace(new RegExp(/,/gi, 'gi'), config.separatorsymbol);\n  }\n  /** This function is to get formated number to be printed in the page */\n\n\n  formatNumber(number, config) {\n    // This is the configuration for 'toLocaleString' method\n    var strConfig = {\n      minimumFractionDigits: config.decimals,\n      maximumFractionDigits: config.decimals\n    }; // Set the number if it using currency, then convert. If doesn't, just parse it as float\n\n    number = config.currency ? this.convertToCurrencySystem(number, config) : parseFloat(number); // Last, apply the number separator using number as string\n\n    return this.applySeparator(number.toLocaleString(undefined, strConfig), config);\n  }\n  /** This function is to get the parsed value */\n\n\n  parseValue(data) {\n    // If number with dot (.), will be parsed as float\n    if (/^[0-9]+\\.[0-9]+$/.test(data)) {\n      return parseFloat(data);\n    } // If just number, will be parsed as integer\n\n\n    if (/^[0-9]+$/.test(data)) {\n      return parseInt(data);\n    } // If it's boolean string, will be parsed as boolean\n\n\n    if (/^true|false/i.test(data)) {\n      return /^true/i.test(data);\n    } // Return it's value as default\n\n\n    return data;\n  }\n  /** This function is to detect the element is in view or not. */\n\n\n  elementIsInView(element) {\n    var top = element.offsetTop;\n    var left = element.offsetLeft;\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n\n    while (element.offsetParent) {\n      element = element.offsetParent;\n      top += element.offsetTop;\n      left += element.offsetLeft;\n    }\n\n    return top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;\n  }\n  /** Just some condition to check browser Intersection Support */\n\n\n  intersectionListenerSupported() {\n    return 'IntersectionObserver' in window && 'IntersectionObserverEntry' in window && 'intersectionRatio' in window.IntersectionObserverEntry.prototype;\n  }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}